function [X, Y, compIdx, info] = tflPlot(W, varargin)
%TFLPLOT  Convenience wrapper: full TFL layout + plotting in one call.
%
%   [X, Y, compIdx, info] = TFLPLOT(W, ...)
%
%   This function runs the full trophic layout pipeline
%   (TROPHICLAYOUTMULTI: analysis + layout + optional barycentre / smoothing)
%   and then plots the result using PLOTTFL.
%
% INPUT
%   W : adjacency matrix (n x n), directed, weighted or unweighted.
%
% OPTIONAL NAME–VALUE PAIRS
%   'LayoutOpts' : scalar struct of options passed to TROPHICLAYOUTMULTI
%   'PlotOpts'   : scalar struct of options passed to PLOTTFL
%
%   Any other name–value pairs are treated as layout options and passed
%   directly to TROPHICLAYOUTMULTI. This is mainly for backwards
%   convenience; for cleaner code, prefer using LayoutOpts / PlotOpts.
%
% EXAMPLES
%
%   % Simplest usage
%   tflPlot(W);
%
%   % With layout options
%   tflPlot(W, 'LayoutOpts', struct( ...
%       'UseBarycentre',      true, ...
%       'CoherenceThreshold', 0.8, ...
%       'UseXSmooth',         true));
%
%   % With plot options
%   tflPlot(W, ...
%       'LayoutOpts', struct('UseBarycentre', false), ...
%       'PlotOpts',   struct('ShowLabels', true, 'NodeSize', 60));
%
% Dependencies (in this repository):
%   trophicLayoutMulti.m
%   plotTFL.m
%
% -------------------------------------------------------------------------

    % ---------- basic checks ----------
    n = size(W,1);
    if size(W,2) ~= n
        error('tflPlot:WNotSquare', 'W must be a square adjacency matrix.');
    end
    if ~isnumeric(W)
        error('tflPlot:WNotNumeric', 'W must be numeric.');
    end

    % Buckets for layout / plot arguments
    layoutArgs = {};
    plotArgs   = {};

    % ---------- parse varargin ----------
    if mod(numel(varargin),2) ~= 0
        error('tflPlot:BadArgs', ...
              'Optional arguments must be name/value pairs.');
    end

    k = 1;
    while k <= numel(varargin)
        name = varargin{k};
        val  = varargin{k+1};

        if ~ischar(name) && ~isstring(name)
            error('tflPlot:BadParamName', ...
                  'Parameter names must be strings.');
        end
        lname = lower(char(name));

        switch lname
            case 'layoutopts'
                % val should be a scalar struct of options for trophicLayoutMulti
                layoutArgs = [layoutArgs, structToNameValue(val)]; %#ok<AGROW>
            case 'plotopts'
                % val should be a scalar struct of options for plotTFL
                plotArgs = [plotArgs, structToNameValue(val)]; %#ok<AGROW>
            otherwise
                % By default, treat everything else as a layout option
                layoutArgs = [layoutArgs, {name, val}]; %#ok<AGROW>
        end
        k = k + 2;
    end

    % ---------- 1. Layout ----------
    [X, Y, compIdx, info] = trophicLayoutMulti(W, layoutArgs{:});

    % ---------- 2. Plot ----------
    % Use the raw trophic heights (h_raw) so bands/labels are in actual
    % trophic units; plotTFL will fit Y ~ a + b*h internally.
    plotTFL(W, X, Y, info.h_raw, plotArgs{:});
end


% =====================================================================
function nv = structToNameValue(s)
%STRUCTTONAMEVALUE  Convert a scalar struct to a name/value cell array.
%
%   nv = STRUCTTONAMEVALUE(s) returns:
%       { 'field1', s.field1, 'field2', s.field2, ... }
%
%   Used to expand LayoutOpts / PlotOpts into varargin-style lists.

    if isempty(s)
        nv = {};
        return;
    end
    if ~isstruct(s) || numel(s) ~= 1
        error('tflPlot:OptsNotStruct', ...
              'LayoutOpts and PlotOpts must be scalar structs.');
    end

    fn = fieldnames(s);
    nv = cell(1, 2*numel(fn));
    for i = 1:numel(fn)
        nv{2*i-1} = fn{i};
        nv{2*i}   = s.(fn{i});
    end
end
