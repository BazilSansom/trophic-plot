
function tfl_test_01_trophic_levels()
%TFL_TEST_01_TROPHIC_LEVELS  Basic tests for trophic_levels.m.
%
% This script exercises trophic_levels on a few small graphs and asserts
% basic invariants:
%   - chains and perfectly layered networks give strictly increasing integer levels
%   - isolates get h = 0
%   - components are recognised correctly
%   - coherence F0 is (approximately) 0 for perfectly layered DAGs
%
% Assumes trophic_levels.m is on the MATLAB path.

fprintf('Running tfl_test_01_trophic_levels...\n');

tol = 1e-10;

%% Test 1: Simple 3-node chain 1 -> 2 -> 3
W = sparse([0 1 0; ...
            0 0 1; ...
            0 0 0]);

[h, info] = trophic_levels(W);

fprintf('Test 1: simple chain 1->2->3\n');
disp('  h ='); disp(h.');

% Expect strictly increasing and min(h) = 0 by default ('min')
assert(numel(h) == 3, 'Test 1: wrong length of h.');
assert(abs(min(h)) < tol, 'Test 1: min(h) should be 0 by default.');
assert(all(diff(h) > 0), 'Test 1: h should be strictly increasing along chain.');

fprintf('  OK.\n\n');

%% Test 2: Chain with ComputeCoherence = true
[h2, info2] = trophic_levels(W, 'ComputeCoherence', true);

fprintf('Test 2: coherence on perfect chain\n');
disp('  h ='); disp(h2.');
disp('  F0_global ='); disp(info2.F0_global);

% Perfect chain with tau_ij = 1 should have F0_global ~ 0
assert(abs(info2.F0_global) < 1e-10, 'Test 2: F0_global should be ~0 for perfect chain.');
assert(abs(info2.C_global - 1) < 1e-10, 'Test 2: C_global should be ~1 for perfect chain.');

fprintf('  OK.\n\n');

%% Test 3: Two components + isolate
% Component 1: 1 -> 2 -> 3
% Component 2: 4 -> 5
% Node 6: isolate
W = sparse(6,6);
W(1,2) = 1;
W(2,3) = 1;
W(4,5) = 1;

[h3, info3] = trophic_levels(W, 'ComputeCoherence', true);

fprintf('Test 3: multi-component + isolate\n');
disp('  h ='); disp(h3.');
disp('  compIdx ='); disp(info3.compIdx.');

% Basic checks
assert(numel(h3) == 6, 'Test 3: wrong length of h.');
assert(info3.nComp >= 2, 'Test 3: should have at least 2 components.');
assert(any(info3.compIdx == info3.compIdx(1)), 'Test 3: node 1 should belong to a component.');
assert(h3(6) == 0, 'Test 3: isolate should have h = 0.');

% Coherence: isolates defined as perfectly layered in this implementation
assert(info3.F0_global >= 0 && info3.F0_global <= 1, 'Test 3: F0_global out of [0,1].');
assert(all(info3.C_comp >= 0 & info3.C_comp <= 1), 'Test 3: C_comp out of [0,1].');

fprintf('  OK.\n\n');

%% Test 4: h0 options ('min', 'wm', 'sm') on a single component
fprintf('Test 4: h0 options (min vs wm vs sm) on a single chain\n');

W4 = sparse([0 1 0; ...
             0 0 1; ...
             0 0 0]);

[h_min, info_min] = trophic_levels(W4, 'h0', 'min', 'ComputeCoherence', false);
[h_wm,  info_wm]  = trophic_levels(W4, 'h0', 'wm',  'ComputeCoherence', false);
[h_sm,  info_sm]  = trophic_levels(W4, 'h0', 'sm',  'ComputeCoherence', false);

assert(info_min.nComp == 1 && info_wm.nComp == 1 && info_sm.nComp == 1, ...
    'Test 4: W4 should be a single component.');

% Now global centering is equivalent to per-component centering
d_min = h_min - mean(h_min);
d_wm  = h_wm  - mean(h_wm);
d_sm  = h_sm  - mean(h_sm);

assert(norm(d_min - d_wm) < 1e-8, 'Test 4: h_min and h_wm differ by more than a constant shift.');
assert(norm(d_min - d_sm) < 1e-8, 'Test 4: h_min and h_sm differ by more than a constant shift.');

fprintf('  OK.\n\n');

%% Test 5: Custom random targets (tau != 1) basic sanity
fprintf('Test 5: custom random targets matrix\n');

% Simple 3-node chain again for clarity: 1 -> 2 -> 3
W5 = sparse([0 1 0; ...
             0 0 1; ...
             0 0 0]);

n5 = size(W5,1);
Tau5 = zeros(n5);

% Assign random target height differences on existing edges
[iE, jE] = find(W5);
% e.g. tau_ij ~ Uniform(0.5, 2.0) on each edge
Tau5(sub2ind(size(Tau5), iE, jE)) = 0.5 + 1.5*rand(numel(iE),1);

[h5, info5] = trophic_levels(W5, 'targets', Tau5, 'ComputeCoherence', true);

fprintf('  h = '); disp(h5.');
fprintf('  F0_global (custom targets) = %.6f\n', info5.F0_global);

% With arbitrary targets, F0 is still a non-negative weighted mean of
% squared deviations, but need not be <= 1. We only assert basic sanity.
assert(isfinite(info5.F0_global), 'Test 5: F0_global must be finite.');
assert(info5.F0_global >= 0,      'Test 5: F0_global should be >= 0.');

fprintf('  OK.\n\n');


%%


fprintf('All basic trophic_levels tests passed.\n');

end
